<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Publication – Ryuki Matsuura</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Ryuki Matsuura</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./publication.html" aria-current="page"> 
<span class="menu-text">Publication</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./fluency_annotation_sys.html"> 
<span class="menu-text">Fluency Annotation System</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#articles-in-refereed-journals" id="toc-articles-in-refereed-journals" class="nav-link active" data-scroll-target="#articles-in-refereed-journals"><strong>Articles in Refereed Journals</strong></a></li>
  <li><a href="#articles-in-refereed-conference-proceedings" id="toc-articles-in-refereed-conference-proceedings" class="nav-link" data-scroll-target="#articles-in-refereed-conference-proceedings"><strong>Articles in Refereed Conference Proceedings</strong></a></li>
  <li><a href="#articles-in-non-refereed-journals-and-conference-proceedings" id="toc-articles-in-non-refereed-journals-and-conference-proceedings" class="nav-link" data-scroll-target="#articles-in-non-refereed-journals-and-conference-proceedings">Articles in Non-Refereed Journals and Conference Proceedings</a></li>
  <li><a href="#presentation" id="toc-presentation" class="nav-link" data-scroll-target="#presentation">Presentation</a>
  <ul class="collapse">
  <li><a href="#invited-talks" id="toc-invited-talks" class="nav-link" data-scroll-target="#invited-talks">Invited Talks</a></li>
  <li><a href="#refereed-paper-and-poster-presentations" id="toc-refereed-paper-and-poster-presentations" class="nav-link" data-scroll-target="#refereed-paper-and-poster-presentations">Refereed Paper and Poster Presentations</a></li>
  <li><a href="#non-refereed-paper-and-poster-presentations" id="toc-non-refereed-paper-and-poster-presentations" class="nav-link" data-scroll-target="#non-refereed-paper-and-poster-presentations">Non-Refereed Paper and Poster Presentations</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Publication</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="articles-in-refereed-journals" class="level2">
<h2 class="anchored" data-anchor-id="articles-in-refereed-journals"><strong>Articles in Refereed Journals</strong></h2>
<ul>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Takizawa, K., Saeki, M., &amp; Matsuyama, Y. (2025). Gauging the Validity of Machine Learning-Based Temporal Feature Annotation to Measure Fluency in Speech Automatically. <em>Research Methods in Applied Linguistics</em>, <em>4</em>(1), 1-23. <a href="https://doi.org/10.1016/j.rmal.2024.100177" class="uri">https://doi.org/10.1016/j.rmal.2024.100177</a></p></li>
<li><p>Arai, Y., <strong>Matsuura, R.</strong>, Eguchi, M., &amp; Suzuki., S. (under review).</p></li>
<li><p>Suzuki, S., Takatsu, H., <strong>Matsuura, R</strong>., Koyama, M., Saeki, M., &amp; Matsuyama, Y. (under review).</p></li>
<li><p>Takatsu, H., Suzuki, S., Eguchi, M., <strong>Matsuura, R.</strong>, Saeki, M., &amp; Matsuyama, Y. (under review).</p></li>
<li><p>Takatsu, H., Suzuki, S., <strong>Matsuura, R.</strong>, Koyama, M., &amp; Matsuyama, Y. (under review).</p></li>
</ul>
</section>
<section id="articles-in-refereed-conference-proceedings" class="level2">
<h2 class="anchored" data-anchor-id="articles-in-refereed-conference-proceedings"><strong>Articles in Refereed Conference Proceedings</strong></h2>
<ul>
<li><p>Saeki, M., Takatsu, H., Kurata, F., Suzuki, S., Eguchi, M., <strong>Matsuura, R.</strong>, Takizawa, K., Yoshikawa, S., &amp; Matsuyama, Y. (2024). InteLLA: Intelligent Language Learning Assistant for Assessing Language Proficiency Through Interviews and Roleplays. Proceedings of SIGDIAL 2024. SIGDIAL 2024. <a href="https://aclanthology.org/2024.sigdial-1.34/" class="uri">https://aclanthology.org/2024.sigdial-1.34/</a></p></li>
<li><p><strong>Matsuura, R.</strong> &amp; Suzuki, S. (2023). Prompt-independent Automated Scoring of L2 Oral Fluency by Capturing Prompt Effects. <em>Proc. of Artificial Intelligence in Education (AIED)</em>. <a href="https://doi.org/10.1007/978-3-031-36272-9_62" class="uri">https://doi.org/10.1007/978-3-031-36272-9_62</a></p></li>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Saeki, M., Ogawa, T., &amp; Matsuyama, Y. (2022). Refinement of Utterance Fluency Feature Extraction and Automated Scoring of L2 Oral Fluency with Dialogic Features. <em>Proc. of Asia-Pacific Signal and Information Processing Association Annual Summit and Conference (APSIPA ASC)</em>. 1312-1320. <a href="https://doi.org/10.23919/APSIPAASC55919.2022.9980148" class="uri">https://doi.org/10.23919/APSIPAASC55919.2022.9980148</a></p></li>
</ul>
</section>
<section id="articles-in-non-refereed-journals-and-conference-proceedings" class="level2">
<h2 class="anchored" data-anchor-id="articles-in-non-refereed-journals-and-conference-proceedings">Articles in Non-Refereed Journals and Conference Proceedings</h2>
<ul>
<li><p>Matsuyama, Y., Saeki, M., Takatsu, H., <strong>Matsuura, R.</strong>, Kurata, F., &amp; Suzuki, S. (2023). InteLLA: Dialog-based English speaking assessment agent that elicits learner’s language ability. Journal of ASJ. 79(3), 162-169. (松山洋一，佐伯真於，高津弘明，松浦瑠希，倉田楓真，鈴木駿吾．(2023)．学習者の能力を引き出す言語運用能力判定エージェント InteLLA の開発と運用．日本音響学会誌．79(3), 162-169.)</p></li>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Saeki, M., Fujie, S., Ogawa, T., &amp; Matsuyama, Y. (2022). Automated Scoring of L2 Oral Fluency Using Dialogic Features. Proc. of Sound Symposium. 2022-SLP-142(47), 1-6. (松浦瑠希，鈴木駿吾，佐伯真於，藤江真也，小川哲司，松山洋一．(2022)．対話特徴を用いた第二言語発話の流暢性自動採点. 音学シンポジウム. 2022-SLP-142(47), 1-6.)</p></li>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Saeki, M., Ogawa, T., &amp; Matsuyama, Y. (2022). Automated scoring of L2 fluency based on detection of disfluency words and pause locations. Proc. of the Acoustical Society of Japan (ASJ). 1351-1354. (松浦瑠希，鈴木駿吾，佐伯真於，小川哲司，松山洋一．(2022)．言い淀みとポーズ位置検出に基づく第二言語発話の流暢性自動採点．日本音響学会研究発表会講演論文集．pp.1351-1354.)</p></li>
<li><p>Saeki, M., <strong>Matsuura, R.</strong>, Suzuki, S., Miyagi, K., Kobayashi, T., Matsuyama, Y. (2021). InteLLA: A Speaking Proficiency Assessment Conversational Agent with Adaptive Interview Strategy. Papers of the special interest group on Spoken Language Understanding and Dialogue processing (SIG-SLUD). 93, 15-20. (佐伯真於，松浦瑠希，鈴木駿吾，宮城琴佳，小林哲則，松山洋一．(2021)．InteLLA：適応的な質問戦略を有するスピーキング能力判定会話エージェント．人工知能学会研究会資料 言語・音声理解と対話処理研究会. 93巻, 15-20.) (<strong>The Japanese Society of Artificial Intelligence Incentive Award</strong>)</p></li>
</ul>
</section>
<section id="presentation" class="level2">
<h2 class="anchored" data-anchor-id="presentation">Presentation</h2>
<section id="invited-talks" class="level3">
<h3 class="anchored" data-anchor-id="invited-talks">Invited Talks</h3>
<ul>
<li><p>Suzuki, S., Saeki, M., &amp; <strong>Matsuura, R.</strong> (2023, June). Pedagogical potential of multimodal conversational AI for foreign language learning and assessment. Paper presented at Korean PhD students and researchers in the UK (KRUK) (Zoom).</p></li>
<li><p>Suzuki, S., Saeki, M., &amp; <strong>Matsuura, R.</strong> (2022, July). Development of Online Language Learning Assistant AI System that Grows with Humans. International Collaborative Practice S V: Computer-Assisted Language Learning, University of Tokyo.</p></li>
<li><p>Suzuki, S. &amp; <strong>Matsuura, R.</strong> (2022, February). L2 oral fluency: From the construct definition to automated scoring. Applied Linguistics Research Circle Weekly Talk, University of Reading (Zoom).</p></li>
</ul>
</section>
<section id="refereed-paper-and-poster-presentations" class="level3">
<h3 class="anchored" data-anchor-id="refereed-paper-and-poster-presentations">Refereed Paper and Poster Presentations</h3>
<ul>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Eguchi, M., Saeki, M., &amp; Matsuyama, Y. (2024, August). Which Lexical Errors Trigger Recasts? Differential Effects of the Rhetorical Role on Dialogic Comprehensibility. AILA. Kuala Lumpur, Malaysia.</p></li>
<li><p>Suzuki, S., Takatsu, H., <strong>Matsuura, R.</strong>, Saeki, M., Arai, Y., &amp; Matsuyama, Y. (2024, July). You may say this better: Consequential validity evidence for diagnostic speaking assessment on lexical use. LTRC. Innsbruck, Austria.</p></li>
<li><p>Sawaki, Y., Arai, Y., Eguchi, M., <strong>Matsuura, R.</strong>, Suzuki. S., &amp; Matsuyama, Y. (2024, July). Building an argument for test score interpretation and use for a fully automated online assessment of L2 spoken interaction. LTRC. Innsbruck, Austria.</p></li>
<li><p>Suzuki, S., Matsuura, R., Inada, Y., Saeki, M., &amp; Matsuyama, Y. (2023, July). What temporal and dialogic features distinguished between second language oral proficiency levels? The case of oral proficiency interview. AILA. Lyon, France.</p></li>
<li><p><strong>Matsuura, R.</strong> &amp; Suzuki, S. (2023, July). Prompt-independent Automated Scoring of L2 Oral Fluency by Capturing Prompt Effects. AIED. Tokyo, Japan.</p></li>
<li><p><strong>Matsuura, R.</strong> (2023, June). Developing and validating automatic annotation system of silent pause locations and disfluency words. LTRC. New York City, USA.</p></li>
<li><p>Matsuyama, Y., Suzuki, S., Saeki, M., Takatsu, H., <strong>Matsuura, R.</strong>, &amp; Arai, Y. (2023, June). Towards an explainable automated scoring of spoken interaction with a conversational AI agent. In J. Eunice, &amp; Y. Sawaki. (Convenors), Technology in Diagnostic and Formative Language Assessment: Friend or Foe? LTRC. New York City, USA.</p></li>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Saeki, M., Ogawa, T., &amp; Matsuyama, Y. (2022, November). Refinement of Utterance Fluency Feature Extraction and Automated Scoring of L2 Oral Fluency with Dialogic Features. APSIPA ASC. Chiang-Mai, Thailand.</p></li>
<li><p>Suzuki, S., <strong>Matsuura, R.</strong>, Saeki, M., &amp; Matsuyama, Y. (2022, August). How is dialogic fluency different from monologic fluency? The case of oral proficiency interview. TBLT. Innsbruck, Austria.</p></li>
<li><p>Suzuki, S., <strong>Matsuura, R.</strong>, Saeki, M., &amp; Matsuyama, Y. (2022, August). What temporal features distinguish between second language oral proficiency levels? The case of Japanese learners of English. Accepted for presentation at the 31st annual conference of the European Second Language Association (EUROSLA), Fribourg, Switzerland.</p></li>
<li><p>Suzuki, S., <strong>Matsuura, R.</strong>, Saeki, M., &amp; Matsuyama, Y. (2022, March). Revisiting the assessment potential of read-aloud speech performance: Cognitive validity and predictive validity. LTRC. Tokyo, Japan.</p></li>
</ul>
</section>
<section id="non-refereed-paper-and-poster-presentations" class="level3">
<h3 class="anchored" data-anchor-id="non-refereed-paper-and-poster-presentations">Non-Refereed Paper and Poster Presentations</h3>
<ul>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Saeki, M., Ogawa, T., &amp; Matsuyama, Y. (2022, March). Automated scoring of L2 fluency based on detection of disfluency words and pause locations. Spring Meeting of ASJ. (松浦瑠希，鈴木駿吾，佐伯真於，小川哲司，松山洋一．(2022, March)．言い淀みとポーズ位置検出に基づく第二言語発話の流暢性自動採点. 日本音響学会研究発表会). Tokyo, Japan. (<strong>Student Presentation Award</strong>).</p></li>
<li><p><strong>Matsuura, R.</strong>, Suzuki, S., Saeki, M., Fujie, S., Ogawa, T., &amp; Matsuyama, Y. (2022, June). Automated Scoring of L2 Oral Fluency Using Dialogic Features. Sound Symposium. (松浦瑠希，鈴木駿吾，佐伯真於，藤江真也，小川哲司，松山洋一．(2022, June)．対話特徴を用いた第二言語発話の流暢性自動採点. 音学シンポジウム). Tokyo, Japan. (<strong>Sponsorship Award</strong>).</p></li>
<li><p><strong>Matsuura, R.</strong>, &amp; Suzuki, S. (2022, December). Automated Scoring of L2 Oral Fluency Based on Speech Production Model. Conference of Transdisciplinary Federation of Science and Technology (traFST). (松浦瑠希，鈴木駿吾．(2022, December)．発話産出モデルに基づく第二言語発話の流暢性自動採点．横幹連合コンファレンス). Tokyo, Japan.</p></li>
<li><p><strong>Matsuura, R.</strong> (2023, October). Automated Scoring of L2 Oral Fluency in Dialogue: Refining of Fluency Feature Extraction &amp; Incorporating Dialogic Features. International Workshop of Speech assessment and native and non-native linguistic variation: trends and methods.</p></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Ryuki Matsuura</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This page is built with ❤️ and <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>